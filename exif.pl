#!/usr/local/bin/perl
#
################################################################
# $Id: exif.pl,v 1.1 2003/04/29 17:40:53 sdonie Exp $
################################################################
#
# CVS Revision: $Revision: 1.1 $
# Commit date:  $Date: 2003/04/29 17:40:53 $
#         Tag:  $Name:  $
#      Author:  $Author: sdonie $
#
################################################################
#
################################################################
#
# This is a modification of the original script by Chris Breeze (see comments below)
# Modifications to original script were done by Martin Krzywinski (martink@bcgsc.ca)
#
# Original script contained Canon-specific parsing of the Makernote. For a very
# comprehensive discourse on EXIF formats please see
#
#    Description of EXIF file format 
#    by TsuruSoh Tachibanaya
#    http://www.ba.wakwak.com/~tsuruzoh/Computer/Digicams/exif-e.html
#
# Changes to some subroutines were made to accomodate EXIF format for 
# Nikon Coolpix cameras. Images from the following models have been tested
#
# 950, 990, 995, 4500, 5000, 5700
#
# I did not keep the original Canon makernote subroutine, nor
# specific formatting for Canon images. 
#
#
# History
#
# 20 Sept 2002: added EXIF IFD attribute information of tags in
#               the xa40(z) range. These are listed in the Jeita CP-3451 document
#
# 15 sept 2002: modified Chris' script to accomodate Nikon Coolpix images
#
#
################################################################
#
# PERL script to extract EXIF information from JPEGs generated by Canon
# digital cameras.
# This software is free and you may do anything like with it except sell it.
#
# Current version: 1.3
# Author: Chris Breeze
# email: chris@breezesys.com
# Web: http://www.breezesys.com
#
# Based on experimenting with my G1 and information from:
# http://www.ba.wakwak.com/~tsuruzoh/Computer/Digicams/exif-e.html
#
# Also Canon MakerNote from David Burren's page:
# http://www.burren.cx/david/canon.html
#
# More EXIF info and specs:
# http://exif.org
#
# Warnings: 
# 1) The Subject distance is unreliable. It seems reasonably accurate
# for the G1 but on the D30 it is highly dependent on the lens fitted.
#
# Perl for Windows is available for free from:
# http://www.activestate.com
#
# History
# 11 Jan 2001
# v0.1: Initial version
#
# 14 Jan 2001
# v0.2: Updated with data from David Burren's page
#
# 15 Jan 2001
# v0.3: Added more info for D30 (supplied by David Burren)
# 1) D30 stores ISO in EXIF tag 0x8827, G1 uses MakerNote 0x1/16
# 2) MakerNote 0x1/10, ImageSize appears to be large, medium, small
# 3) D30 allows 1/2 or 1/3 stop exposure compensation
# 4) Added D30 custom function details, but can't test them
#
# 17 Jan 2001
# v1.0 Tidied up AutoFocusMode for G1 vs D30 + added manual auto focus point (D30)
#
# 18 Jan 2001
# v1.1 Removed some debug code left in by mistake
#
# 29 Jan 2001
# v1.2 Added flash mode (MakerNote Tag 1, field 4)
#
# 7 Mar 2001
# v1.3 Added ImageQuality (MakerNote Tag 1, field 3)
#
# 21 Apr 2001
# v1.4 added ImageStabilisation for Pro90 IS
#
# 17 Sep 2001
# v1.5 Incorporated D30 improvements from Jim Leonard

use strict;
my $debug = 0;			# output debug info

my $intelAlignment = 0;		# byte alignment - read from EXIF header

my $cameraModel;

open(IN, $ARGV[0]) || die "Please specify a filename.\n\ne.g. $0 myfile.jpg\n$ARGV[0] invalid\nquitting";

binmode IN;			# Tell Windoze that we're reading a binary file

# markers are FFXX where XX is one of those below
my %jpeg_markers = (
		    SOF	 => chr(0xc0), #
		    DHT	 => chr(0xc4), # Define Huffman table
		    SOI	 => chr(0xd8), # Start of image
		    EOI	 => chr(0xd9), # End of image
		    SOS	 => chr(0xda), #
		    DQT	 => chr(0xdb), # Define quantisation table
		    DRI	 => chr(0xdd), # Define quantisation table
		    APP1 => chr(0xe1), # APP1 - where EXIF data is stored
		   );

# tags associated with Nikon Makernote (brand-specific EXIF fields)

#my %coolpixtags = (
#		   0x1  => "UNKNOWN",
#		   0x2  => "ISOSetting",
#		   0x3  => "ColorMode",
#		   0x4  => "QualityValue",
# 		   0x5  => "WhiteBalance",
# 		   0x6  => "Sharpening",
# 		   0x7  => "Focus",
# 		   0x8  => "Flash",
# 		   0x9  => "0x9",
# 		   0xa  => "UNKNOWN",
# 		   0xb  => "0xb",
# 		   0xf  => "ISOSelection",
# 		   0x10 => "UNKNOWN",
# 		   0xe00 => "UNKNOWN",
# 		   0x11 => "ThumbnailImageIFD",
# 		   0x80 => "ImageAdjust",
# 		   0x82 => "Lens",
# 		   0x85 => "ManualFocus",
# 		   0x86 => "Digizoom",
# 		   0x88 => "AFFocusPosition",
# 		   0x8f => "0x8f",
# 		   0x94 => "0x94",
# 		   0x95 => "NoiseReduction",
# 		   0x9b => "0x9b",
# 		   0xf00 => "0xf00",
# 		  );

my %casiotags = (
        0x1 => "RecordingMode",
        0x2 => "Quality",
        0x3 => "FocusingMode",
        0x4 => "FlashMode",
        0x5 => "FlashIntensity",
        0x6 => "ObjectDistance",
        0x7 => "WhiteBalance",
        0x8 => "unknown",
        0x9 => "unknown",
        0xa => "DigitalZoom",
        0xb => "Sharpness",
        0xc => "Contrast",
        0xd => "Saturation",
        0xe => "unknown",
        0xf => "unknown",
        0x10 => "unknown",
        0x11 => "unknown",
        0x12 => "unknown",
        0x13 => "unknown",
        0x14 => "Sensitivity",
  );

# Special data offsets for coolpix models. Others are computed automatically.

my %modeloffsets = (
		    "E950"  => 8,
		    "E995"  => 0,
		   );

# Once a tag is parsed, you can get the value with $tagvalues{TEXT} where TEXT is
# the text-value of a tag in the %coolpixtags and %tagid hashes.

my %tagvalues;

# EXIF tag maps

my %tagid = (
	     0x10e  => "ImageDescription",
	     0x10f  => "Make",
	     0x110  => "Model",
	     0x112  => "Orientation",
	     0x11a  => "XResolution",
	     0x11b  => "YResolution",
	     0x128  => "ResolutionUnit",
	     0x131  => "Software",
	     0x132  => "DateTime",
	     0x213  => "YCbCrPositioning",
	     0x8769 => "EXIFOffset",
	     0x103  => "Compression",
	     0x201  => "JPEGInterchangeFormat",
	     0x202  => "JPEGInterchangeFormatLength",
	     0x829A => "ExposureTime",
	     0x829D => "FNumber",
	     0x8769 => "EXIFSubIFD",
	     0x8822 => "ExposureProgram",
	     0x8827 => "ISOSpeedRating",
	     0x9000 => "EXIFVersion",
	     0x9003 => "DateTimeOriginal",
	     0x9004 => "DateTimeDigitized",
	     0x9101 => "ComponentsConfiguration",
	     0x9102 => "CompressedBitsPerPixel",
	     0x9204 => "ExposureBiasValue",
	     0x9205 => "MaxApertureValue",
	     0x9207 => "MeteringMode",
	     0x9208 => "LightSource",
	     0x9209 => "Flash",
	     0x920A => "FocalLength",
	     0x927c => "MakerNote",
	     0x9286 => "UserComment",
	     0xA000 => "FlashPixVersion",
	     0xA001 => "ColorSpace",
	     0xA002 => "EXIFImageWidth",
	     0xA003 => "EXIFImageLength",
	     0xA005 => "InteroperabilityOffset",
	     0xA300 => "FileSource",
	     0xA301 => "SceneType",
	     0xA401 => "CustomRendered",
	     0xA402 => "ExposureMode",
	     0xA403 => "WhiteBalance",
	     0xA404 => "DigitalZoomRatio",
	     0xA405 => "FocalLength35",
	     0xA406 => "SceneCaptureType",
	     0xA407 => "GainControl",
	     0xA408 => "Contrast",
	     0xA409 => "Saturation",
	     0xA40a => "Sharpness",
	     0xA40c => "SubjectDistanceRange",
	     0x9c9B => "MSSummary",
	    );

while (!eof(IN)) {
  # JPEG file is made up of blocks which start with a
  # 2 byte marker: 0xff, marker
  my $ch;
  if (! read(IN,$ch,1)) {
    debug("end of file reached");
    exit;
  }

  # image data doesn't start with 0xff
  if(ord($ch) != 0xff) {
    debug("! 0xff - last");
    last;
  }
  my $marker;
  if(! read(IN,$marker,1)) {
    debug("end of file reached while reading marker");
    exit;
  }
  if ($marker eq $jpeg_markers{SOI}) {
    debug("[M] SOI");
  } elsif ($marker eq $jpeg_markers{EOI}) {
    debug("[M] EOI");
  } else {

    my ($msb, $lsb, $data, $size);

    # Markers other than SOI and EOI have associated data
    # next 2 bytes are the length of this block (including themselves)
    die "Error reading length" if !read(IN, $msb, 1);
    die "Error reading length" if !read(IN, $lsb, 1);
    $size = 256 * ord($msb) + ord($lsb);

    # remainder of the block is size - 2 bytes long
    die "File truncated" if read(IN, $data, $size - 2) != $size - 2;

    if ($marker eq $jpeg_markers{APP1}) {
      # APP1 block contains the EXIF data
      debug("[M] APP1: $size bytes");
      exif($data);
    } elsif ($marker eq $jpeg_markers{DQT}) {
      debug("[M]  DQT: $size bytes");
    } elsif ($marker eq $jpeg_markers{SOF0}) {
      debug("[M] SOF0: $size bytes");
    } elsif ($marker eq $jpeg_markers{DHT}) {
      debug("[M]  DHT: $size bytes");
    } elsif ($marker eq $jpeg_markers{SOS}) {
      debug("[M] SOSh: $size bytes");
    } else {
      debug(sprintf("Unknown marker: 0x%04x, size: $size\n", $marker));
    }
  }
}
close IN;

print "\ncomments $tagvalues{'UserComment'}";

sub exif
  {
    my ($data) = @_;

    # first 6 bytes should be the EXIF header: 'Exif\0\0'
    my $header = substr($data, 0, 6);
    die "APP1 does not contain EXIF data\n" if ($header ne "Exif\0\0");
    debug("Reading EXIF data");
    $data = substr($data, 6);

    # check TIFF header: Byte align/TAG/Offset to first IFD
    if (substr($data, 0, 2) eq 'II') {
      debug("Intel byte alignment");
      $intelAlignment = 1;
    } elsif (substr($data, 0, 2) eq 'MM') {
      debug("Motorola byte alignment");
      $intelAlignment = 0;
    } else {
      die "Invalid byte alignment";
    }

    # check EXIF tag (0x002a)
    debug ("Invalid tag mark") if readShort($data, 2) != 0x002a;

    # read offset to first IFD
    my $offset = readLong($data, 4);
    debug("Offset to first IFD: $offset");

    # first 2 bytes of IFD define the number of 12-byte entries
    my $numEntries = readShort($data, $offset);
    $offset += 2;
    debug("Number of directory entries: $numEntries");

    my $i;
    for ($i = 0; $i < $numEntries; $i++) {
      # Each entry is made up of 12 bytes
      # Tag (2 bytes)
      # Format (2 bytes)
      # Num components (4 bytes)
      # Data or offset to data if longer than 4 bytes (4 bytes)
      my $entry = substr($data, $offset + 12 * $i, 12);
      my $tag = readShort($entry, 0);
      my $format = readShort($entry, 2);
      my $components = readLong($entry, 4);
      my $offset = readLong($entry, 8);

      # Read the value using the appropriate format
      my $value =	readIFDEntry($data, $format, $components, $offset,$entry);

      # Decode individual EXIF tags

      if($tagid{$tag}) {
        # Deal with special tags
        if($tagid{$tag} eq "EXIFSubIFD")
        {
          exifSubIFD($data, $offset);
        } elsif ($tagid{$tag} eq "MakerNote") {

        } else {
          reporttag($tag,$format,$components,$offset,$value);
          $tagvalues{$tagid{$tag}} = $value;
        }
      } else {
        printf("Unrecognised entry: TAG=0x%x, $value\n", $tag);
      }
    }
    $offset = readLong($data, $offset + 12 * $numEntries);
    debug("Offset to next IFD: $offset");
  }


# Extract EXIF sub IFD info
sub exifSubIFD  {

  my ($data, $offset) = @_;
  debug("EXIF: offset=$offset");

    # IFD starts with the number of entries
    my $numEntries = readShort($data, $offset);
    $offset += 2;
    debug("Number of directory entries: $numEntries");

    # Read the 12-byte long entries
    my $i;
    for ($i = 0; $i < $numEntries; $i++) {
      my $entry = substr($data, $offset + 12 * $i, 12);
      my $tag = readShort($entry, 0);
      my $format = readShort($entry, 2);
      my $components = readLong($entry, 4);
      my $offset = readLong($entry, 8);

      my $value =	readIFDEntry($data, $format, $components, $offset, $entry);

      if($tagid{$tag}) {
        if($tagid{$tag} eq "MakerNote") {
            makerNote($data, $offset);
          } else {
            reporttag($tag,$format,$components,$offset,$value);
        }
      } else {
        printf("Unrecognised entry: TAG=0x%x, $value\n", $tag);
      }
    }
}


# MakerNote: Nikon-specific processing
sub makerNote
  {
    my ($data, $offset) = @_;

    # uncomment if you want to see the makernote data
    #for (0..100) {
      #printf("%02d %04d ",$_,12*$_);
      #printhex(substr($data,$offset+$_*12,12));
    #}

    my $header = substr($data,$offset,10);
    my $coolpixoffset = 0;
    my $idfoffset     = 0;

    if(defined $modeloffsets{$tagvalues{"Model"}}) {
      $offset += $modeloffsets{$tagvalues{"Model"}};
      debug ("adding model offset");
    } else {
      if($header =~ /Nikon/i) {
      	$offset    += 18;
      	$idfoffset = $offset-8;
      } else {
        # do nothing
        debug ("no makerNote offset needed");
      }
    }

    my $numEntries = readShort($data,$offset);

    $offset += 2;

    debug("Number of directory entries: $numEntries");

    my $i;

    for ($i = 0; $i < $numEntries; $i++) {
      my $entry      = substr($data, $offset + 12 * $i, 12);
      my $tag        = readShort($entry, 0);
      my $format     = readShort($entry, 2);
      my $components = readLong($entry, 4);
      my $offset     = readLong($entry, 8);

      my $value = readIFDEntry($data, $format, $components, $offset+$idfoffset, $entry);

      #printhex($entry);

      if($casiotags{$tag}) {
	       reporttag($tag,$format,$components,$offset,$value,\%casiotags);
      } else {
        	printf("MakerNote: unrecognised TAG: 0x%x, format: $format, components: $components, offset: $offset\n", $tag);
        	my $value = readIFDEntry($data, $format, $components, $offset);
        	print "value: $value\n";
      }
      #print "-"x80,"\n";
    }
  }

# read 2-byte short, byte aligned according to $intelAlignment
sub readShort
  {
    my ($data, $offset) = @_;
    die "readShort: end of string reached" if length($data) < $offset + 2;
    my $ch1 = ord(substr($data, $offset++, 1));
    my $ch2 = ord(substr($data, $offset++, 1));
    if ($intelAlignment) {
      return $ch1 + 256 * $ch2;
    }
    return $ch2 + 256 * $ch1;
  }

# read 4-byte long, byte aligned according to $intelAlignment
sub readLong
  {
    my ($data, $offset) = @_;
    die "readLong: end of string reached" if length($data) < $offset + 4;
    my $ch1 = ord(substr($data, $offset++, 1));
    my $ch2 = ord(substr($data, $offset++, 1));
    my $ch3 = ord(substr($data, $offset++, 1));
    my $ch4 = ord(substr($data, $offset++, 1));
    if ($intelAlignment) {
      return (((($ch4 * 256) + $ch3) * 256) + $ch2) * 256 + $ch1;
    }
    return (((($ch1 * 256) + $ch2) * 256) + $ch3) * 256 + $ch4;
  }

# read formatted IFD entry
sub readIFDEntry
  {
    my ($data, $format, $components, $offset, $entry) = @_;
    if ($format == 2) {
      # ASCII string
      my $value = substr($data, $offset, $components);
      $value =~ s/\0+$//;	# remove trailing NULL chars
      return $value;
    } elsif ($format == 3) {
      if($components == 2) {
      	# two components and a short int - probably a pair of values
      	#printhex($entry);
      	my $v1 = readShort($entry,8,2);
      	my $v2 = readShort($entry,10,2);
      	return "$v1,$v2";
      }
      # Unsigned short
      if (!$intelAlignment) {
      	$offset = 0xffff & ($offset >> 16);
      }
      return $offset;
    } elsif ($format == 4) {
      # Unsigned long
      return $offset;
    } elsif ($format == 5) {
      # Unsigned rational
      my $numerator = readLong($data, $offset);
      my $denominator = readLong($data, $offset + 4);
      #print "$numerator / $denominator\n";
      if($denominator) {
	       return "$numerator/$denominator";
      }
    } elsif ($format == 10) {
      # Signed rational
      my $numerator = readLong($data, $offset);
      $numerator -= 2 ** 32 if ($numerator > 2 ** 31);
      my $denominator = readLong($data, $offset + 4);
      #print "$numerator / $denominator\n";
      if($denominator) {
	       return "$numerator/$denominator";
      }
    } elsif ($format ==7) {
      if($components == 4) {
      	# if the format is 7 (undefined) and there are 4 components,
      	# return the chr values of the offset data field - hoping
      	# that these are useful data values
      	#
      	# for example, 0x0088 is 'AF Focus Position' and its values
      	# are
      	#
      	# 00 00 00 00 center
      	# 00 01 00 00 top
      	# 00 02 00 00 bottom, etc.
      	# printhex($entry);
      	my @v = unpack("c*",substr($entry,8,4));
      	return join(",",@v);
      }
      return $offset;
    } elsif ($format ==8) {
      # signed short
      return $offset;
    } else {
      return 0;
    }
  }

sub debug {
  print "@_\n" if $debug;
}

sub reporttag {
  my ($tag,$format,$components,$offset,$value,$tagidhash) = @_;
  if(! $tagidhash) {
    $tagidhash = \%tagid;
  }
  if($tagidhash->{$tag} ne "UNKNOWN") {
    printf ("TAGINFO %04X %2d %3d %30s %s\n",$tag,$format,$components,$tagidhash->{$tag},$value);
  }
}

### debugging functions

sub printhex {
  my $data = shift;
  my @hex;
  my @ascii;
  foreach (0..length($data)) {
    my $bytevalue = substr($data,$_,1);
    push(@hex,unpack("H*",$bytevalue));
    push(@ascii,$bytevalue);
  }
  print join(" ",map {uc} @hex);
  foreach (@ascii) {
    if(ord($_) > 21 && ord($_) < 128) {
      print $_;
    } else {
      print ".";
    }
  }
  print "\n";
}
